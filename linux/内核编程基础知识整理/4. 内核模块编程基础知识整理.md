# Linux内核模块开发与编译基础

## 1. **内核模块概述**

### **什么是内核模块？**
内核模块是可以在运行时动态加载到内核中的代码，扩展内核功能而无需重新编译整个内核。

### **特点：**
- 动态加载/卸载
- 运行在内核空间
- 可以访问内核所有符号
- 与内核版本紧密相关

## 2. **最简单的内核模块**

### **基本结构**
```c
// hello.c - 最简单的内核模块
#include <linux/init.h>   // 包含初始化宏
#include <linux/module.h> // 包含内核模块相关函数
#include <linux/kernel.h> // 包含内核打印函数

MODULE_LICENSE("GPL");              // 模块许可证
MODULE_AUTHOR("Your Name");         // 作者信息
MODULE_DESCRIPTION("A simple example Linux module.");  // 模块描述
MODULE_VERSION("1.0");              // 模块版本

// 模块初始化函数
static int __init hello_init(void)
{
    printk(KERN_INFO "Hello, World!\n");
    return 0;  // 返回0表示成功
}

// 模块清理函数
static void __exit hello_exit(void)
{
    printk(KERN_INFO "Goodbye, World!\n");
}

// 注册模块的初始化和清理函数
module_init(hello_init);
module_exit(hello_exit);
```

## 3. **Makefile编写**

### **基本Makefile**
```makefile
# 最简Makefile
obj-m += hello.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

### **完整Makefile示例**
```makefile
# 定义内核源码目录（根据实际环境修改）
KERNEL_DIR ?= /lib/modules/$(shell uname -r)/build

# 目标模块名（.ko文件）
obj-m += hello.o

# 如果有多个源文件
# obj-m += module_name.o
# module_name-objs := file1.o file2.o

# 当前目录
PWD := $(shell pwd)

# 编译目标
all:
    $(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules

# 清理
clean:
    $(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean

# 安装模块
install:
    sudo insmod hello.ko

# 卸载模块
uninstall:
    sudo rmmod hello

# 查看模块信息
info:
    modinfo hello.ko

# 查看内核日志
log:
    dmesg | tail -20

# 编译并安装
deploy: all install

# 测试完整流程
test: clean all install uninstall
```

## 4. **编译环境准备**

### **安装开发工具**
```bash
# Ubuntu/Debian
sudo apt-get update
sudo apt-get install build-essential linux-headers-$(uname -r)

# CentOS/RHEL/Fedora
sudo yum groupinstall "Development Tools"
sudo yum install kernel-devel-$(uname -r)

# 验证内核头文件
ls /lib/modules/$(uname -r)/build
```

### **检查内核配置**
```bash
# 确认内核支持模块加载
cat /boot/config-$(uname -r) | grep CONFIG_MODULES

# 确认版本匹配
uname -r
ls /lib/modules/$(uname -r)/build/ -la
```

## 5. **编译过程详解**

### **编译步骤**
```bash
# 1. 编写模块代码 hello.c 和 Makefile
# 2. 执行编译
make

# 编译输出文件：
# hello.mod.c   - 模块依赖信息
# hello.mod.o   - 编译后的模块信息
# hello.o       - 模块目标文件
# hello.ko      - 最终的内核模块文件
# modules.order - 模块编译顺序
# Module.symvers - 符号版本信息
```

### **编译错误排查**
```bash
# 1. 检查内核头文件
ls -la /lib/modules/$(uname -r)/

# 2. 安装正确的头文件
sudo apt-get install linux-headers-$(uname -r)

# 3. 如果提示找不到内核源码
# 可能需要手动指定KERNEL_DIR
make KERNEL_DIR=/usr/src/linux-headers-$(uname -r)

# 4. 常见错误解决
# 错误：scripts/sign-file.c:25:30: fatal error: openssl/opensslv.h
sudo apt-get install libssl-dev
```

## 6. **模块操作命令**

### **加载和卸载模块**
```bash
# 加载模块
sudo insmod hello.ko

# 查看已加载模块
lsmod | grep hello

# 查看模块信息
sudo modinfo hello.ko

# 卸载模块
sudo rmmod hello

# 带参数加载
sudo insmod hello.ko param1=value1 param2=value2
```

### **系统管理命令**
```bash
# 查看所有模块
lsmod

# 查看模块详细信息
modinfo <module_name>

# 查看模块依赖关系
modprobe --show-depends <module_name>

# 自动解决依赖加载
sudo modprobe <module_name>

# 查看模块输出
dmesg | tail -20
journalctl -k --since="1 hour ago" | tail -50
```

## 7. **带参数的模块**

### **添加模块参数**
```c
// param.c - 带参数的模块
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/moduleparam.h>

MODULE_LICENSE("GPL");

// 定义参数
static char *mystring = "default";
static int myint = 100;
static int myarray[5] = {1, 2, 3, 4, 5};
static int arr_argc = 0;

// 注册参数
module_param(mystring, charp, 0644);        // 字符串参数
MODULE_PARM_DESC(mystring, "A character string");

module_param(myint, int, 0644);             // 整数参数
MODULE_PARM_DESC(myint, "An integer");

module_param_array(myarray, int, &arr_argc, 0644);  // 数组参数
MODULE_PARM_DESC(myarray, "An array of integers");

// 初始化函数
static int __init param_init(void)
{
    int i;
    
    printk(KERN_INFO "Module loaded with parameters:\n");
    printk(KERN_INFO "  mystring = %s\n", mystring);
    printk(KERN_INFO "  myint = %d\n", myint);
    
    printk(KERN_INFO "  myarray contains %d values:\n", arr_argc);
    for (i = 0; i < arr_argc; i++) {
        printk(KERN_INFO "    myarray[%d] = %d\n", i, myarray[i]);
    }
    
    return 0;
}

static void __exit param_exit(void)
{
    printk(KERN_INFO "Module unloaded\n");
}

module_init(param_init);
module_exit(param_exit);
```

### **使用参数**
```bash
# 编译
make

# 加载时指定参数
sudo insmod param.ko mystring="hello" myint=42 myarray=10,20,30

# 查看sysfs中的参数
ls /sys/module/param/parameters/
cat /sys/module/param/parameters/mystring

# 运行时修改参数（如果权限允许）
echo "newvalue" | sudo tee /sys/module/param/parameters/mystring
```

## 8. **模块符号导出**

### **创建导出符号的模块**
```c
// export.c - 导出符号的模块
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

// 要导出的函数
int export_add(int a, int b)
{
    return a + b;
}
EXPORT_SYMBOL(export_add);  // 导出给其他模块使用

// 导出的变量
int export_var = 1234;
EXPORT_SYMBOL(export_var);

// 仅限GPL模块使用的符号
void gpl_function(void)
{
    printk(KERN_INFO "This is a GPL-only function\n");
}
EXPORT_SYMBOL_GPL(gpl_function);  // 仅GPL模块可用

static int __init export_init(void)
{
    printk(KERN_INFO "Export module loaded\n");
    return 0;
}

static void __exit export_exit(void)
{
    printk(KERN_INFO "Export module unloaded\n");
}

module_init(export_init);
module_exit(export_exit);
```

### **使用导出符号的模块**
```c
// import.c - 使用其他模块的符号
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");

// 声明外部符号
extern int export_add(int, int);
extern int export_var;

static int __init import_init(void)
{
    int result;
    
    printk(KERN_INFO "Import module loaded\n");
    
    // 使用导出的函数
    result = export_add(10, 20);
    printk(KERN_INFO "10 + 20 = %d\n", result);
    
    // 使用导出的变量
    printk(KERN_INFO "export_var = %d\n", export_var);
    
    return 0;
}

static void __exit import_exit(void)
{
    printk(KERN_INFO "Import module unloaded\n");
}

module_init(import_init);
module_exit(import_exit);
```

### **编译多个模块**
```makefile
obj-m += export.o import.o

all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

## 9. **字符设备驱动示例**

### **简单字符设备驱动**
```c
// chardev.c - 简单的字符设备驱动
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>        // 文件操作结构
#include <linux/cdev.h>      // 字符设备
#include <linux/uaccess.h>   // copy_to_user/copy_from_user

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");

#define DEVICE_NAME "mychardev"
#define CLASS_NAME "chardev"

static int major_number;
static struct class* chardev_class = NULL;
static struct cdev my_cdev;

// 设备数据
static char message[256] = {0};
static int message_len = 0;

// 文件操作函数
static int dev_open(struct inode *inodep, struct file *filep)
{
    printk(KERN_INFO "chardev: Device opened\n");
    return 0;
}

static ssize_t dev_read(struct file *filep, char *buffer, size_t len, loff_t *offset)
{
    int bytes_to_copy;
    int bytes_copied;
    
    // 计算要拷贝的字节数
    bytes_to_copy = min((size_t)(message_len - *offset), len);
    if (bytes_to_copy <= 0)
        return 0;
    
    // 拷贝数据到用户空间
    bytes_copied = copy_to_user(buffer, message + *offset, bytes_to_copy);
    if (bytes_copied) {
        printk(KERN_ERR "chardev: Failed to copy %d bytes to user\n", bytes_copied);
        return -EFAULT;
    }
    
    *offset += bytes_to_copy;
    printk(KERN_INFO "chardev: Sent %d bytes to user\n", bytes_to_copy);
    
    return bytes_to_copy;
}

static ssize_t dev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
{
    int bytes_to_copy;
    
    // 限制写入长度
    bytes_to_copy = min((size_t)sizeof(message) - 1, len);
    
    // 从用户空间拷贝数据
    if (copy_from_user(message, buffer, bytes_to_copy)) {
        printk(KERN_ERR "chardev: Failed to copy %d bytes from user\n", bytes_to_copy);
        return -EFAULT;
    }
    
    message_len = bytes_to_copy;
    message[message_len] = '\0';  // 确保字符串终止
    
    printk(KERN_INFO "chardev: Received %d bytes from user: %s\n", bytes_to_copy, message);
    
    return bytes_to_copy;
}

static int dev_release(struct inode *inodep, struct file *filep)
{
    printk(KERN_INFO "chardev: Device closed\n");
    return 0;
}

// 文件操作结构
static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = dev_open,
    .read = dev_read,
    .write = dev_write,
    .release = dev_release,
};

// 模块初始化
static int __init chardev_init(void)
{
    dev_t dev_num;
    
    printk(KERN_INFO "chardev: Initializing\n");
    
    // 1. 分配设备号
    if (alloc_chrdev_region(&dev_num, 0, 1, DEVICE_NAME) < 0) {
        printk(KERN_ERR "chardev: Failed to allocate device number\n");
        return -1;
    }
    major_number = MAJOR(dev_num);
    printk(KERN_INFO "chardev: Registered with major number %d\n", major_number);
    
    // 2. 创建设备类
    chardev_class = class_create(THIS_MODULE, CLASS_NAME);
    if (IS_ERR(chardev_class)) {
        unregister_chrdev_region(dev_num, 1);
        printk(KERN_ERR "chardev: Failed to create device class\n");
        return PTR_ERR(chardev_class);
    }
    
    // 3. 创建设备文件
    device_create(chardev_class, NULL, dev_num, NULL, DEVICE_NAME);
    
    // 4. 初始化cdev结构
    cdev_init(&my_cdev, &fops);
    my_cdev.owner = THIS_MODULE;
    
    // 5. 添加cdev到系统
    if (cdev_add(&my_cdev, dev_num, 1) < 0) {
        device_destroy(chardev_class, dev_num);
        class_destroy(chardev_class);
        unregister_chrdev_region(dev_num, 1);
        printk(KERN_ERR "chardev: Failed to add cdev\n");
        return -1;
    }
    
    return 0;
}

// 模块清理
static void __exit chardev_exit(void)
{
    dev_t dev_num = MKDEV(major_number, 0);
    
    printk(KERN_INFO "chardev: Exiting\n");
    
    // 清理设备
    device_destroy(chardev_class, dev_num);
    class_destroy(chardev_class);
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_num, 1);
    
    printk(KERN_INFO "chardev: Cleanup completed\n");
}

module_init(chardev_init);
module_exit(chardev_exit);
```

### **测试字符设备**
```bash
# 编译加载模块
make
sudo insmod chardev.ko

# 查看设备
ls -l /dev/mychardev
cat /proc/devices | grep mychardev

# 测试设备
echo "Hello Driver" > /dev/mychardev
cat /dev/mychardev
dd if=/dev/urandom of=/dev/mychardev bs=100 count=1

# 查看日志
dmesg | tail -20

# 清理
sudo rmmod chardev
```

## 10. **调试技巧**

### **调试输出**
```c
// 使用不同级别的printk
printk(KERN_EMERG   "Emergency message\n");
printk(KERN_ALERT   "Alert message\n");
printk(KERN_CRIT    "Critical message\n");
printk(KERN_ERR     "Error message\n");
printk(KERN_WARNING "Warning message\n");
printk(KERN_NOTICE  "Notice message\n");
printk(KERN_INFO    "Info message\n");
printk(KERN_DEBUG   "Debug message\n");

// 条件调试
#ifdef DEBUG
#define debug_printk(fmt, ...) printk(KERN_DEBUG fmt, ##__VA_ARGS__)
#else
#define debug_printk(fmt, ...) 
#endif
```

### **proc文件系统调试**
```c
// 创建/proc文件接口
#include <linux/proc_fs.h>

static struct proc_dir_entry *proc_entry;

static ssize_t proc_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
    char data[100];
    int len;
    
    len = snprintf(data, sizeof(data), "Module status: loaded\n");
    
    return simple_read_from_buffer(buf, count, ppos, data, len);
}

static const struct proc_ops proc_fops = {
    .proc_read = proc_read,
};

// 在init函数中创建
proc_entry = proc_create("my_module_info", 0644, NULL, &proc_fops);

// 在exit函数中删除
proc_remove(proc_entry);
```

## 11. **常见问题与解决**

### **编译问题**
```bash
# 1. 内核版本不匹配
# 解决方案：安装正确的内核头文件
sudo apt-get install linux-headers-$(uname -r)

# 2. 缺少build目录符号链接
# 解决方案：创建链接
sudo ln -s /usr/src/linux-headers-$(uname -r) /lib/modules/$(uname -r)/build

# 3. 权限问题
# 使用sudo或确保有足够权限
```

### **加载问题**
```bash
# 1. 模块版本不匹配
# 加载时跳过版本检查
sudo insmod module.ko

# 2. 依赖缺失
# 查看依赖关系
modinfo module.ko

# 3. 内存不足
# 检查系统内存
free -h
```

## 12. **最佳实践**

1. **错误处理**：所有内核函数都可能失败，必须检查返回值
2. **资源释放**：init失败时要释放已分配的资源
3. **并发安全**：考虑多处理器和中断上下文
4. **内存管理**：使用内核内存分配函数（kmalloc/kfree）
5. **版本兼容**：使用适当的宏保持跨版本兼容性
6. **文档注释**：详细注释代码，特别是复杂部分

## 13. **项目结构示例**
```
my_driver/
├── Makefile              # 编译配置
├── README.md            # 项目说明
├── src/
│   ├── main.c          # 主模块代码
│   ├── device.c        # 设备相关代码
│   ├── ioctl.c         # IOCTL接口
│   └── debug.c         # 调试功能
├── include/
│   └── my_driver.h     # 头文件
├── test/
│   └── test_app.c      # 测试程序
└── scripts/
    └── load.sh         # 自动加载脚本
```

掌握这些基础知识后，你就可以开始开发自己的内核模块了。从简单的Hello World开始，逐步增加功能，最终可以开发完整的设备驱动。