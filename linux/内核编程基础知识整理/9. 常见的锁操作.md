# Linux内核编程中常用的锁

Linux内核提供了多种同步机制，根据不同的使用场景选择合适的锁至关重要。

## 1. **自旋锁（Spinlock）**

### 特点
- **忙等待**：获取不到锁时原地自旋
- **开销小**：适合短期持有（< CPU时间片）
- **不可休眠**：不能在持有自旋锁时睡眠

### 基本用法
```c
#include <linux/spinlock.h>

// 定义和初始化
DEFINE_SPINLOCK(my_lock);  // 静态初始化
// 或
spinlock_t my_lock;
spin_lock_init(&my_lock);  // 动态初始化

// 获取锁
spin_lock(&my_lock);
// 临界区操作
spin_unlock(&my_lock);

// 配合中断使用
unsigned long flags;
spin_lock_irqsave(&my_lock, flags);  // 保存中断状态并禁止本地中断
// 临界区
spin_unlock_irqrestore(&my_lock, flags);  // 恢复中断状态

// 如果确定中断未开启
spin_lock_irq(&my_lock);
spin_unlock_irq(&my_lock);
```

### 变种：读写自旋锁
```c
DEFINE_RWLOCK(my_rwlock);

// 读锁（共享）
read_lock(&my_rwlock);
// 读取操作
read_unlock(&my_rwlock);

// 写锁（独占）
write_lock(&my_rwlock);
// 写入操作
write_unlock(&my_rwlock);
```

## 2. **信号量（Semaphore）**

### 特点
- **睡眠等待**：获取不到锁时进程休眠
- **可计数**：允许多个持有者
- **开销较大**：涉及上下文切换

### 用法
```c
#include <linux/semaphore.h>

// 初始化
struct semaphore my_sem;
sema_init(&my_sem, 1);  // 计数初始化为1（互斥信号量）

// 获取信号量
if (down_interruptible(&my_sem)) {  // 可被信号中断
    // 被信号中断，返回-EINTR
    return -ERESTARTSYS;
}

// 非中断版本
down(&my_sem);  // 不可中断

// 尝试获取，不等待
if (down_trylock(&my_sem)) {
    // 获取失败
}

// 释放信号量
up(&my_sem);
```

## 3. **互斥锁（Mutex）**

### 特点
- **替代信号量**：更简单高效的互斥机制
- **可递归检测**：防止同一任务重复获取
- **有死锁检测**：调试特性

### 用法
```c
#include <linux/mutex.h>

// 定义和初始化
DEFINE_MUTEX(my_mutex);  // 静态
// 或
struct mutex my_mutex;
mutex_init(&my_mutex);   // 动态

// 获取锁
mutex_lock(&my_mutex);
// 或可中断版本
if (mutex_lock_interruptible(&my_mutex)) {
    return -ERESTARTSYS;
}

// 尝试获取
if (mutex_trylock(&my_mutex)) {
    // 获取成功
} else {
    // 获取失败
}

// 释放锁
mutex_unlock(&my_mutex);
```

## 4. **读写信号量（rw_semaphore）**

### 特点
- 类似读写自旋锁，但可睡眠
- 适合读多写少的场景

```c
#include <linux/rwsem.h>

DECLARE_RWSEM(my_rwsem);  // 静态初始化

// 读锁
down_read(&my_rwsem);
// 读取操作
up_read(&my_rwsem);

// 写锁
down_write(&my_rwsem);
// 写入操作
up_write(&my_rwsem);

// 尝试升级（读锁升级为写锁）
// 需谨慎使用，可能死锁
```

## 5. **RCU（Read-Copy-Update）**

### 特点
- **无锁读取**：读操作完全不加锁
- **延迟释放**：写操作后延迟释放旧数据
- **适合读多写极少**：高性能但使用复杂

```c
#include <linux/rcupdate.h>

struct my_data {
    int value;
    struct rcu_head rcu;
};

// 读取端
rcu_read_lock();
struct my_data *data = rcu_dereference(global_ptr);
// 使用data，但不能睡眠
int val = data->value;
rcu_read_unlock();

// 更新端
struct my_data *new_data = kmalloc(sizeof(*new_data), GFP_KERNEL);
new_data->value = 42;

// 替换指针
struct my_data *old_data = rcu_dereference_protected(global_ptr, 1);
rcu_assign_pointer(global_ptr, new_data);

// 延迟释放旧数据
if (old_data) {
    call_rcu(&old_data->rcu, my_free_callback);
}

// 回调函数
static void my_free_callback(struct rcu_head *rcu)
{
    struct my_data *data = container_of(rcu, struct my_data, rcu);
    kfree(data);
}
```

## 6. **顺序锁（seqlock）**

### 特点
- **乐观锁**：适合读多写少，读取频繁但冲突少
- **写者优先**：写入时会重试读取

```c
#include <linux/seqlock.h>

// 定义
seqlock_t my_seqlock = DEFINE_SEQLOCK(my_seqlock);

// 读取端
unsigned int seq;
do {
    seq = read_seqbegin(&my_seqlock);
    // 读取数据
    value = shared_data;
} while (read_seqretry(&my_seqlock, seq));

// 写入端
write_seqlock(&my_seqlock);
// 写入操作
shared_data = new_value;
write_sequnlock(&my_seqlock);
```

## 7. **完成变量（completion）**

### 特点
- 等待某个事件完成
- 常用于模块初始化、线程同步

```c
#include <linux/completion.h>

DECLARE_COMPLETION(my_completion);

// 等待方
wait_for_completion(&my_completion);

// 可中断版本
wait_for_completion_interruptible(&my_completion);

// 带超时版本（返回剩余时间）
unsigned long timeout = msecs_to_jiffies(1000);
if (!wait_for_completion_timeout(&my_completion, timeout)) {
    // 超时处理
}

// 完成方
complete(&my_completion);        // 唤醒一个等待者
complete_all(&my_completion);    // 唤醒所有等待者
```

## 8. **原子操作（Atomic）**

### 特点
- 最小粒度的同步
- CPU指令级原子性

```c
#include <linux/atomic.h>

atomic_t counter = ATOMIC_INIT(0);  // 初始化

// 操作
atomic_inc(&counter);           // 加1
atomic_dec(&counter);           // 减1
atomic_add(10, &counter);       // 加10
atomic_sub(5, &counter);        // 减5

// 读取和设置
int val = atomic_read(&counter);
atomic_set(&counter, 100);

// 条件操作
if (atomic_dec_and_test(&counter)) {
    // 减到0时执行
}
```

## 9. **每CPU变量（per-CPU variables）**

### 特点
- 每个CPU有自己的副本，无需加锁
- 适合统计、计数等场景

```c
#include <linux/percpu.h>

// 声明
DEFINE_PER_CPU(int, my_counter);

// 获取当前CPU的变量
int *ptr = this_cpu_ptr(&my_counter);
*ptr += 1;

// 安全访问（禁止抢占）
int *ptr = get_cpu_ptr(&my_counter);
*ptr += 1;
put_cpu_ptr(&my_counter);

// 遍历所有CPU
for_each_possible_cpu(cpu) {
    int *ptr = per_cpu_ptr(&my_counter, cpu);
    printk("CPU%d: %d\n", cpu, *ptr);
}
```

## 锁的选择指南

| 场景 | 推荐锁 | 理由 |
|------|--------|------|
| 短期保护，不能睡眠 | 自旋锁 | 开销小，忙等待 |
| 长期保护，可能睡眠 | 互斥锁 | 可睡眠，有死锁检测 |
| 读多写少，可睡眠 | 读写信号量 | 读并发性好 |
| 读多写少，不能睡眠 | 读写自旋锁 | 读并发且不睡眠 |
| 读多写极少 | RCU | 读取完全无锁 |
| 读多写少，冲突少 | 顺序锁 | 乐观锁，性能好 |
| 等待事件完成 | 完成变量 | 专门用于同步 |
| 简单计数/标志 | 原子操作 | 无锁，高性能 |
| 每个CPU独立数据 | 每CPU变量 | 完全无锁 |

## 最佳实践

1. **锁粒度**：尽量细化，减少持有时间
2. **锁顺序**：固定获取顺序，避免死锁
3. **中断上下文**：只能用自旋锁，注意中断屏蔽
4. **性能考虑**：
   - 临界区短→自旋锁
   - 临界区长→互斥锁
   - 读多写少→读写锁/RCU

5. **调试辅助**：
```c
// 锁依赖检测（需要配置CONFIG_PROVE_LOCKING）
# 查看锁统计
cat /proc/lock_stat

// 死锁检测（需要配置CONFIG_DEBUG_LOCK_ALLOC）
```

## 常见错误

```c
// 错误：中断中使用可能睡眠的锁
irq_handler() {
    mutex_lock(&lock);  // 可能睡眠，错误！
}

// 正确：中断中用自旋锁
irq_handler() {
    spin_lock(&lock);
}

// 错误：重复获取同一锁
mutex_lock(&lock);
mutex_lock(&lock);  // 死锁！

// 正确：使用递归锁或重构代码
```

选择正确的锁是内核编程的关键，需要根据具体场景权衡性能、复杂性和安全性。