Linux内核中广泛使用的链表主要有以下几种，每种都有特定的用途：

## 1. **双向循环链表（最常用）**

### 数据结构
```c
struct list_head {
    struct list_head *next, *prev;
};
```

### 基本用法
```c
// 定义包含链表的自定义结构
struct my_data {
    int value;
    struct list_head list;  // 链表节点
};

// 初始化
struct list_head my_list;
INIT_LIST_HEAD(&my_list);  // 或 LIST_HEAD(my_list)

// 添加元素
struct my_data *data = kmalloc(sizeof(*data), GFP_KERNEL);
data->value = 10;
INIT_LIST_HEAD(&data->list);
list_add(&data->list, &my_list);          // 添加到头部
list_add_tail(&data->list, &my_list);     // 添加到尾部

// 遍历链表
struct list_head *pos;
struct my_data *entry;

list_for_each(pos, &my_list) {
    entry = list_entry(pos, struct my_data, list);
    printk(KERN_INFO "Value: %d\n", entry->value);
}

// 遍历的简化版本（常用）
struct my_data *entry;
list_for_each_entry(entry, &my_list, list) {
    printk(KERN_INFO "Value: %d\n", entry->value);
}

// 安全遍历（支持删除）
struct my_data *entry, *tmp;
list_for_each_entry_safe(entry, tmp, &my_list, list) {
    if (entry->value == 10) {
        list_del(&entry->list);
        kfree(entry);
    }
}
```

## 2. **哈希链表（hlist）**

用于哈希表，只有单向链表头，节省内存。

```c
// 数据结构
struct hlist_head {
    struct hlist_node *first;
};

struct hlist_node {
    struct hlist_node *next, **pprev;
};

// 使用示例
struct hlist_head my_hash[HTABLE_SIZE];

struct my_hash_data {
    int key;
    int value;
    struct hlist_node node;
};

// 初始化哈希表
for (i = 0; i < HTABLE_SIZE; i++)
    INIT_HLIST_HEAD(&my_hash[i]);

// 添加元素
struct my_hash_data *data = kmalloc(sizeof(*data), GFP_KERNEL);
data->key = 5;
data->value = 100;
unsigned int bucket = data->key % HTABLE_SIZE;
hlist_add_head(&data->node, &my_hash[bucket]);

// 遍历
struct hlist_node *pos;
struct my_hash_data *entry;

hlist_for_each_entry(entry, pos, &my_hash[bucket], node) {
    if (entry->key == 5) {
        // 找到元素
    }
}
```

## 3. **红黑树（rbtree）**

用于需要高效查找的场景。

```c
#include <linux/rbtree.h>

struct my_rb_data {
    int key;
    int value;
    struct rb_node node;
};

// 根节点
struct rb_root my_tree = RB_ROOT;

// 插入函数
int my_insert(struct rb_root *root, struct my_rb_data *data)
{
    struct rb_node **new = &(root->rb_node), *parent = NULL;
    
    while (*new) {
        struct my_rb_data *this = container_of(*new, struct my_rb_data, node);
        parent = *new;
        
        if (data->key < this->key)
            new = &((*new)->rb_left);
        else if (data->key > this->key)
            new = &((*new)->rb_right);
        else
            return -EEXIST;  // 键已存在
    }
    
    rb_link_node(&data->node, parent, new);
    rb_insert_color(&data->node, root);
    return 0;
}

// 查找
struct my_rb_data *my_search(struct rb_root *root, int key)
{
    struct rb_node *node = root->rb_node;
    
    while (node) {
        struct my_rb_data *data = container_of(node, struct my_rb_data, node);
        
        if (key < data->key)
            node = node->rb_left;
        else if (key > data->key)
            node = node->rb_right;
        else
            return data;
    }
    return NULL;
}
```

## 4. **单向链表（llist）**

用于不需要双向遍历的场景，更节省内存。

```c
// 数据结构
struct llist_node {
    struct llist_node *next;
};

struct llist_head {
    struct llist_node *first;
};

// 使用示例（常用于工作队列）
struct my_llist_data {
    struct llist_node node;
    int data;
};

LLIST_HEAD(my_llist);

// 添加元素
struct my_llist_data *item = kmalloc(sizeof(*item), GFP_KERNEL);
item->data = 42;
llist_add(&item->node, &my_llist);
```

## 5. **kfifo（环形缓冲区）**

用于生产者-消费者场景。

```c
#include <linux/kfifo.h>

// 静态声明
DECLARE_KFIFO(my_fifo, char, 1024);

// 或动态分配
struct kfifo fifo;
kfifo_alloc(&fifo, 1024, GFP_KERNEL);

// 写入数据
char data[] = "Hello";
kfifo_in(&fifo, data, strlen(data));

// 读取数据
char buffer[100];
unsigned int len = kfifo_out(&fifo, buffer, sizeof(buffer));
```

## 主要API函数总结

### list_head常用函数：
- `INIT_LIST_HEAD()` / `LIST_HEAD()` - 初始化链表
- `list_add()` / `list_add_tail()` - 添加节点
- `list_del()` / `list_del_init()` - 删除节点
- `list_empty()` - 检查链表是否为空
- `list_for_each()` - 遍历节点
- `list_for_each_entry()` - 遍历容器
- `list_entry()` - 获取容器指针

### 选择建议：
1. **通用双向链表** → `list_head`
2. **哈希表** → `hlist`
3. **需要快速查找/排序** → `rbtree`
4. **生产者-消费者** → `kfifo`
5. **无锁单生产者单消费者** → `llist`

这些数据结构都在`<linux/list.h>`、`<linux/rbtree.h>`等头文件中定义，是Linux内核编程的基础组件。