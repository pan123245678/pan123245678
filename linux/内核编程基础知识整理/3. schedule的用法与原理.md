# Linux内核schedule()用法与原理详解

## 1. **schedule()的基本用法**

### **功能概述**
`schedule()`是Linux内核的调度器入口函数，用于主动放弃CPU，触发调度器选择另一个进程运行。

### **基本调用方式**
```c
#include <linux/sched.h>

void schedule(void);
```

### **使用场景**
```c
// 示例1：长时间循环中主动让出CPU
while (!kthread_should_stop()) {
    // 执行一些工作
    do_some_work();
    
    // 主动让出CPU，避免饥饿其他进程
    schedule();
}

// 示例2：等待条件满足
while (!condition) {
    // 设置进程状态为可中断睡眠
    set_current_state(TASK_INTERRUPTIBLE);
    
    // 让出CPU，等待被唤醒
    schedule();
    
    // 恢复运行状态
    set_current_state(TASK_RUNNING);
}
```

## 2. **schedule()的工作原理**

### **调度器调用流程**
```
schedule()
    ↓
__schedule()
    ↓
pick_next_task()      # 选择下一个运行的进程
    ↓
context_switch()      # 执行上下文切换
    ↓
switch_mm()           # 切换地址空间
    ↓
switch_to()           # 切换寄存器状态
```

### **核心数据结构**
```c
// 调度器类结构
struct sched_class {
    const struct sched_class *next;
    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);
    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);
    struct task_struct * (*pick_next_task) (struct rq *rq);
    void (*put_prev_task) (struct rq *rq, struct task_struct *p);
    // ... 其他方法
};

// 运行队列
struct rq {
    struct task_struct *curr;      // 当前运行进程
    struct task_struct *idle;      // idle进程
    struct task_struct *stop;      // stop进程
    unsigned long nr_running;      // 可运行进程数
    // ... 其他字段
};
```

## 3. **schedule()的详细用法**

### **配合进程状态使用**
```c
// 正确的使用模式
static int my_thread_func(void *data)
{
    while (!kthread_should_stop()) {
        // 模式1：简单让出CPU
        if (need_reschedule()) {
            schedule();
        }
        
        // 模式2：等待事件（推荐）
        DEFINE_WAIT(wait);
        
        while (!event_occurred) {
            prepare_to_wait(&event_waitqueue, &wait, TASK_INTERRUPTIBLE);
            
            if (!event_occurred)
                schedule();  // 调度器会自动处理状态切换
            
            finish_wait(&event_waitqueue, &wait);
        }
        
        // 模式3：定时延迟
        set_current_state(TASK_INTERRUPTIBLE);
        schedule_timeout(HZ);  // 睡眠1秒
        
        // 模式4：无条件让出CPU
        cond_resched();  // 轻量级的schedule()，只在需要时调度
    }
    return 0;
}
```

### **与睡眠/唤醒机制配合**
```c
#include <linux/wait.h>

static DECLARE_WAIT_QUEUE_HEAD(my_waitqueue);
static int data_ready = 0;

// 生产者线程
static int producer_thread(void *data)
{
    // 生产数据
    produce_data();
    
    data_ready = 1;
    
    // 唤醒等待的消费者
    wake_up(&my_waitqueue);
    
    return 0;
}

// 消费者线程
static int consumer_thread(void *data)
{
    DEFINE_WAIT(wait);
    
    while (!kthread_should_stop()) {
        prepare_to_wait(&my_waitqueue, &wait, TASK_INTERRUPTIBLE);
        
        if (!data_ready) {
            // 主动让出CPU，等待被唤醒
            schedule();
        }
        
        finish_wait(&my_waitqueue, &wait);
        
        if (data_ready) {
            // 消费数据
            consume_data();
            data_ready = 0;
        }
    }
    
    return 0;
}
```

## 4. **schedule()的实现原理**

### **核心代码分析（简化版）**
```c
// kernel/sched/core.c
asmlinkage __visible void __sched schedule(void)
{
    struct task_struct *tsk = current;
    
    // 1. 关闭内核抢占
    preempt_disable();
    
    // 2. 检查调度时机
    if (unlikely(need_resched())) {
        // 3. 调用真正的调度器
        __schedule(false);
    }
    
    // 4. 重新启用抢占
    preempt_enable();
}

static void __sched notrace __schedule(bool preempt)
{
    struct task_struct *prev, *next;
    struct rq *rq;
    
    // 获取当前CPU的运行队列
    rq = cpu_rq(smp_processor_id());
    prev = rq->curr;
    
    // 1. 执行调度前的准备工作
    schedule_debug(prev);
    
    // 2. 选择下一个要运行的进程
    next = pick_next_task(rq, prev);
    
    // 3. 如果选择的进程不同，执行上下文切换
    if (likely(prev != next)) {
        rq->nr_switches++;
        rq->curr = next;
        
        // 执行实际的上下文切换
        context_switch(rq, prev, next);
    }
    
    // 4. 重新平衡运行队列（SMP系统）
    balance_callback(rq);
}
```

### **进程选择算法**
```c
// 简化版pick_next_task
static inline struct task_struct *
pick_next_task(struct rq *rq)
{
    // 检查实时进程（优先级高）
    if (has_rt_policy(rq))
        return pick_next_rt_task(rq);
    
    // 检查公平调度进程（CFS）
    if (has_fair_policy(rq))
        return pick_next_fair_task(rq);
    
    // 返回idle进程
    return rq->idle;
}
```

## 5. **schedule_timeout()的使用**

```c
#include <linux/delay.h>
#include <linux/sched.h>

// 睡眠指定时间（秒）
ssleep(seconds);

// 睡眠指定时间（毫秒）
msleep(milliseconds);

// 更精确的超时控制
unsigned long timeout = jiffies + HZ * 5;  // 5秒后

while (!condition) {
    if (time_after(jiffies, timeout)) {
        printk(KERN_INFO "Timeout occurred\n");
        break;
    }
    
    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(HZ);  // 每次睡眠1秒
}
```

## 6. **cond_resched()的使用**

```c
// 条件调度：只在需要时调度
static void long_running_function(void)
{
    unsigned long i;
    
    for (i = 0; i < 1000000; i++) {
        do_work();
        
        // 每1000次迭代检查是否需要调度
        if (i % 1000 == 0) {
            cond_resched();  // 比schedule()更轻量
        }
    }
}
```

## 7. **调度策略与优先级**

```c
// 设置调度策略和优先级
static void set_thread_scheduling(struct task_struct *tsk)
{
    struct sched_param param = {0};
    
    // 设置实时调度策略（优先级1-99）
    sched_setscheduler_nocheck(tsk, SCHED_FIFO, &param);
    param.sched_priority = 50;  // 中等优先级
    sched_setscheduler_nocheck(tsk, SCHED_FIFO, &param);
    
    // 或者设置公平调度（普通进程）
    // 优先级通过nice值控制（-20到19）
    set_user_nice(tsk, -5);  // 较高优先级
    
    // 设置CPU亲和性
    cpumask_t mask;
    cpumask_clear(&mask);
    cpumask_set_cpu(0, &mask);  // 绑定到CPU0
    set_cpus_allowed_ptr(tsk, &mask);
}
```

## 8. **调试和监控**

### **查看调度信息**
```bash
# 查看进程调度信息
cat /proc/<pid>/sched

# 查看上下文切换次数
cat /proc/<pid>/status | grep voluntary_ctxt_switches
cat /proc/<pid>/status | grep nonvoluntary_ctxt_switches

# 使用tracepoints跟踪调度事件
echo 1 > /sys/kernel/debug/tracing/events/sched/enable
cat /sys/kernel/debug/tracing/trace_pipe
```

### **在内核中添加调度调试**
```c
#include <linux/sched/task.h>

static void debug_schedule_info(void)
{
    printk(KERN_INFO "Current process: %s (PID: %d)\n", 
           current->comm, current->pid);
    printk(KERN_INFO "State: %ld\n", current->state);
    printk(KERN_INFO "Flags: %lx\n", current->flags);
    printk(KERN_INFO "Need resched: %d\n", test_tsk_need_resched(current));
}
```

## 9. **最佳实践和注意事项**

1. **避免在中断上下文中调用schedule()**：这是不允许的
2. **正确设置进程状态**：调用schedule()前通常需要设置进程状态
3. **注意锁的使用**：调度前应释放可能阻塞其他进程的锁
4. **考虑CPU亲和性**：长时间运行的线程应考虑绑定CPU
5. **使用适当的调度策略**：根据任务性质选择调度策略
6. **避免忙等待**：应使用等待队列而不是忙等待循环

## 10. **性能优化建议**

```c
// 优化前：可能造成CPU浪费
while (!condition) {
    // 空循环浪费CPU
}

// 优化后：使用调度器
while (!condition) {
    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(HZ/10);  // 每100ms检查一次
}

// 进一步优化：使用等待队列
DEFINE_WAIT(wait);
prepare_to_wait(&wq, &wait, TASK_INTERRUPTIBLE);
if (!condition)
    schedule();
finish_wait(&wq, &wait);
```

`schedule()`是Linux内核调度的核心机制，正确使用它可以提高系统响应性和公平性，同时避免资源浪费。在实际开发中，应根据具体场景选择合适的调度方式和参数。