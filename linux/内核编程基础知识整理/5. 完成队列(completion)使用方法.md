# Linux内核完成队列（completion）使用方法

## 1. **完成队列基本概念**

完成队列是Linux内核中的一种**同步机制**，用于一个线程等待另一个线程完成某个操作。

### **核心思想：**
- **等待者**：调用`wait_for_completion()`进入睡眠，等待事件完成
- **完成者**：调用`complete()`或`complete_all()`唤醒等待者

## 2. **基本使用方法**

### **2.1 定义和初始化**
```c
#include <linux/completion.h>

// 方法1：静态定义和初始化
static DECLARE_COMPLETION(my_completion);

// 方法2：动态初始化
struct completion my_completion;
init_completion(&my_completion);

// 方法3：重新初始化（重用完成量）
reinit_completion(&my_completion);
```

### **2.2 简单示例**
```c
#include <linux/module.h>
#include <linux/kthread.h>
#include <linux/completion.h>

static struct task_struct *worker_thread;
static DECLARE_COMPLETION(work_done);

static int worker_function(void *data)
{
    printk(KERN_INFO "Worker: Starting work...\n");
    
    // 模拟工作
    msleep(1000);
    
    printk(KERN_INFO "Worker: Work completed\n");
    
    // 通知工作完成
    complete(&work_done);
    
    return 0;
}

static int __init test_init(void)
{
    printk(KERN_INFO "Main: Starting worker thread\n");
    
    worker_thread = kthread_run(worker_function, NULL, "worker");
    
    printk(KERN_INFO "Main: Waiting for work completion\n");
    
    // 等待工作完成
    wait_for_completion(&work_done);
    
    printk(KERN_INFO "Main: Work done, continuing\n");
    
    return 0;
}
```

## 3. **核心API函数**

### **等待函数**
```c
// 1. 无限等待（不可中断）
void wait_for_completion(struct completion *comp);

// 2. 可中断等待（可被信号打断）
int wait_for_completion_interruptible(struct completion *comp);
// 返回值：0-成功完成，-ERESTARTSYS-被信号打断

// 3. 超时等待（毫秒）
unsigned long wait_for_completion_timeout(struct completion *comp, 
                                          unsigned long timeout);
// 返回值：剩余时间（超时为0）

// 4. 可中断+超时等待
long wait_for_completion_interruptible_timeout(struct completion *comp,
                                                unsigned long timeout);
```

### **完成函数**
```c
// 1. 唤醒一个等待者
void complete(struct completion *comp);

// 2. 唤醒所有等待者
void complete_all(struct completion *comp);

// 3. 尝试唤醒（非阻塞）
bool try_wait_for_completion(struct completion *comp);
// 返回值：true-无需等待，false-需要等待

// 4. 销毁完成量（可选）
void destroy_completion(struct completion *comp);
```

## 4. **完整示例：生产者-消费者模型**

```c
#include <linux/module.h>
#include <linux/kthread.h>
#include <linux/completion.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");

#define NUM_WORKERS 3

static struct task_struct *workers[NUM_WORKERS];
static DECLARE_COMPLETION(worker_ready[NUM_WORKERS]);
static DECLARE_COMPLETION(all_workers_done);

// 工作线程函数
static int worker_thread(void *data)
{
    int id = *(int *)data;
    
    printk(KERN_INFO "Worker %d: Starting\n", id);
    
    // 模拟初始化工作
    msleep(id * 100);
    
    printk(KERN_INFO "Worker %d: Ready\n", id);
    
    // 通知主线程本线程已就绪
    complete(&worker_ready[id]);
    
    // 等待开始工作的信号
    wait_for_completion(&all_workers_done);
    
    printk(KERN_INFO "Worker %d: Received start signal, working...\n", id);
    
    // 执行实际工作
    msleep(500);
    
    printk(KERN_INFO "Worker %d: Work completed\n", id);
    
    return 0;
}

// 主模块初始化
static int __init completion_test_init(void)
{
    int i;
    int ids[NUM_WORKERS];
    
    printk(KERN_INFO "Main: Starting %d workers\n", NUM_WORKERS);
    
    // 创建工作线程
    for (i = 0; i < NUM_WORKERS; i++) {
        ids[i] = i;
        workers[i] = kthread_run(worker_thread, &ids[i], "worker%d", i);
        if (IS_ERR(workers[i])) {
            printk(KERN_ERR "Failed to create worker %d\n", i);
            return PTR_ERR(workers[i]);
        }
    }
    
    printk(KERN_INFO "Main: Waiting for all workers to be ready\n");
    
    // 等待所有工作线程就绪
    for (i = 0; i < NUM_WORKERS; i++) {
        wait_for_completion(&worker_ready[i]);
    }
    
    printk(KERN_INFO "Main: All workers ready. Starting work...\n");
    
    // 通知所有工作线程开始工作
    complete_all(&all_workers_done);
    
    // 等待工作线程完成（简化处理，实际应该分别等待）
    msleep(1000);
    
    printk(KERN_INFO "Main: All work should be done now\n");
    
    return 0;
}

static void __exit completion_test_exit(void)
{
    int i;
    
    printk(KERN_INFO "Module exiting\n");
    
    // 停止工作线程（实际应该更优雅地停止）
    for (i = 0; i < NUM_WORKERS; i++) {
        if (workers[i])
            kthread_stop(workers[i]);
    }
}

module_init(completion_test_init);
module_exit(completion_test_exit);
```

## 5. **实际应用场景**

### **场景1：模块初始化同步**
```c
static DECLARE_COMPLETION(module_init_done);

// 硬件初始化线程
static int hardware_init_thread(void *data)
{
    // 初始化硬件
    init_hardware();
    
    // 通知主线程硬件初始化完成
    complete(&module_init_done);
    
    return 0;
}

static int __init my_module_init(void)
{
    struct task_struct *init_thread;
    
    printk(KERN_INFO "Starting hardware initialization\n");
    
    init_thread = kthread_run(hardware_init_thread, NULL, "hw_init");
    
    // 等待硬件初始化完成
    if (wait_for_completion_timeout(&module_init_done, HZ * 5) == 0) {
        printk(KERN_ERR "Hardware initialization timeout!\n");
        return -ETIMEDOUT;
    }
    
    printk(KERN_INFO "Hardware initialized, module ready\n");
    
    return 0;
}
```

### **场景2：批量任务处理**
```c
#define MAX_TASKS 10

struct task_item {
    struct completion done;
    int task_id;
    void *data;
};

static void process_task(struct task_item *task)
{
    printk(KERN_INFO "Processing task %d\n", task->task_id);
    
    msleep(100);  // 模拟处理时间
    
    // 任务完成，通知等待者
    complete(&task->done);
}

// 主线程等待多个任务完成
static void wait_for_tasks(struct task_item tasks[], int count)
{
    int i;
    
    for (i = 0; i < count; i++) {
        // 启动任务处理（可以是线程、工作队列等）
        schedule_work(&tasks[i].work);
    }
    
    // 等待所有任务完成
    for (i = 0; i < count; i++) {
        wait_for_completion(&tasks[i].done);
    }
    
    printk(KERN_INFO "All %d tasks completed\n", count);
}
```

## 6. **高级用法和注意事项**

### **6.1 与工作队列结合**
```c
#include <linux/workqueue.h>

struct work_data {
    struct work_struct work;
    struct completion completion;
    int result;
};

static void work_handler(struct work_struct *work)
{
    struct work_data *data = container_of(work, struct work_data, work);
    
    // 执行工作
    data->result = do_work();
    
    // 工作完成
    complete(&data->completion);
}

static int use_workqueue_with_completion(void)
{
    struct work_data data;
    
    // 初始化完成量
    init_completion(&data.completion);
    
    // 初始化工作
    INIT_WORK(&data.work, work_handler);
    
    // 提交到工作队列
    schedule_work(&data.work);
    
    // 等待工作完成
    wait_for_completion(&data.completion);
    
    return data.result;
}
```

### **6.2 使用注意事项**
```c
// 注意事项：

// 1. 不能重复初始化正在使用的完成量
// 错误示例：
wait_for_completion(&comp);
init_completion(&comp);  // 错误！正在使用中

// 正确做法：
wait_for_completion(&comp);
reinit_completion(&comp);  // 重用完成量

// 2. 完成量是单一事件，不能重复使用
// 如果想多次等待同一事件，需要重新初始化

// 3. 竞态条件防护
static DEFINE_MUTEX(lock);
DECLARE_COMPLETION(done);

// 线程A
mutex_lock(&lock);
if (condition) {
    complete(&done);
}
mutex_unlock(&lock);

// 线程B
mutex_lock(&lock);
if (!condition) {
    mutex_unlock(&lock);
    wait_for_completion(&done);
} else {
    mutex_unlock(&lock);
}
```

### **6.3 性能优化建议**
```c
// 1. 使用超时避免永久阻塞
unsigned long timeout = msecs_to_jiffies(5000);  // 5秒超时
if (wait_for_completion_timeout(&comp, timeout) == 0) {
    // 超时处理
    printk(KERN_WARNING "Operation timeout\n");
    return -ETIMEDOUT;
}

// 2. 使用可中断等待处理信号
if (wait_for_completion_interruptible(&comp)) {
    // 被信号中断
    printk(KERN_INFO "Wait interrupted by signal\n");
    return -ERESTARTSYS;
}

// 3. 避免不必要的完成量
// 如果只需要一次性同步，考虑使用原子变量或简单的等待队列
```

## 7. **完成量内部实现简析**

```c
// 简化版完成量结构
struct completion {
    unsigned int done;          // 完成计数器
    wait_queue_head_t wait;     // 等待队列
};

// wait_for_completion 伪代码：
void wait_for_completion(struct completion *x)
{
    unsigned long flags;
    
    spin_lock_irqsave(&x->wait.lock, flags);
    if (!x->done) {
        // 添加到等待队列
        __add_wait_queue(&x->wait, ...);
        
        do {
            // 设置进程状态并调度
            set_current_state(TASK_UNINTERRUPTIBLE);
            spin_unlock_irqrestore(&x->wait.lock, flags);
            schedule();
            spin_lock_irqsave(&x->wait.lock, flags);
        } while (!x->done);
    }
    x->done--;
    spin_unlock_irqrestore(&x->wait.lock, flags);
}

// complete 伪代码：
void complete(struct completion *x)
{
    unsigned long flags;
    
    spin_lock_irqsave(&x->wait.lock, flags);
    x->done++;
    // 唤醒等待队列中的一个进程
    __wake_up_locked(&x->wait, TASK_NORMAL, 1);
    spin_unlock_irqrestore(&x->wait.lock, flags);
}
```

## 8. **与其它同步机制对比**

| 机制 | 用途 | 特点 | 适用场景 |
|------|------|------|----------|
| **completion** | 线程间一次性事件通知 | 轻量级，专为"完成"场景设计 | 初始化完成、任务完成 |
| **wait_queue** | 通用等待/唤醒 | 更灵活，可自定义唤醒条件 | 复杂等待条件 |
| **semaphore** | 资源计数 | 允许多个持有者 | 资源池管理 |
| **mutex** | 互斥访问 | 同一时间只有一个持有者 | 临界区保护 |
| **condition** | 条件变量 | 需要与互斥锁配合使用 | 复杂同步逻辑 |

## 9. **调试技巧**

```c
// 1. 添加调试信息
#define DEBUG_COMPLETION

#ifdef DEBUG_COMPLETION
#define comp_debug(fmt, ...) \
    printk(KERN_DEBUG "COMPLETION %s:%d: " fmt, \
           __func__, __LINE__, ##__VA_ARGS__)
#else
#define comp_debug(fmt, ...)
#endif

// 2. 跟踪完成量状态
static void debug_completion_state(struct completion *comp, const char *op)
{
#ifdef DEBUG_COMPLETION
    printk(KERN_DEBUG "Completion %p: %s (done=%u)\n", 
           comp, op, comp->done);
#endif
}

// 使用
debug_completion_state(&my_comp, "before wait");
wait_for_completion(&my_comp);
debug_completion_state(&my_comp, "after wait");
```

## 10. **总结**

完成队列是Linux内核中最简单、最常用的同步机制之一：

### **核心要点：**
1. **初始化**：使用`DECLARE_COMPLETION()`或`init_completion()`
2. **等待**：使用`wait_for_completion()`系列函数
3. **通知**：使用`complete()`或`complete_all()`
4. **重用**：使用`reinit_completion()`重置状态

### **最佳实践：**
- 使用超时避免永久阻塞
- 考虑使用可中断版本处理信号
- 配合互斥锁防止竞态条件
- 完成量只适合一次性事件通知

### **简单记忆：**
```c
// 线程A
DECLARE_COMPLETION(done);
// ... 做一些初始化
complete(&done);  // 通知完成

// 线程B
wait_for_completion(&done);  // 等待完成
// ... 继续执行
```

完成队列特别适合**初始化同步**、**任务完成通知**等简单场景，比信号量和等待队列更轻量、更易用。