# Linux内核等待队列（wait_queue）使用方法

## 1. **等待队列基本概念**

等待队列是Linux内核中用于线程休眠和唤醒的**核心同步机制**，比完成队列更灵活。

### **核心思想：**
- **等待者**：加入等待队列，进入睡眠状态
- **唤醒者**：条件满足时，唤醒等待队列中的一个或多个线程

## 2. **基本使用方法**

### **2.1 定义和初始化等待队列**
```c
#include <linux/wait.h>
#include <linux/sched.h>

// 方法1：静态定义和初始化
static DECLARE_WAIT_QUEUE_HEAD(my_waitqueue);

// 方法2：动态初始化
wait_queue_head_t my_waitqueue;
init_waitqueue_head(&my_waitqueue);
```

### **2.2 最简单的等待-唤醒示例**
```c
#include <linux/module.h>
#include <linux/kthread.h>

static wait_queue_head_t data_waitqueue;
static int data_ready = 0;

// 消费者线程：等待数据
static int consumer_thread(void *data)
{
    printk(KERN_INFO "Consumer: Waiting for data...\n");
    
    // 等待数据就绪
    wait_event_interruptible(data_waitqueue, data_ready != 0);
    
    printk(KERN_INFO "Consumer: Got data! data_ready = %d\n", data_ready);
    return 0;
}

// 生产者线程：产生数据并唤醒消费者
static int producer_thread(void *data)
{
    printk(KERN_INFO "Producer: Producing data...\n");
    
    msleep(2000);  // 模拟生产时间
    
    data_ready = 1;
    printk(KERN_INFO "Producer: Data ready, waking up consumer\n");
    
    // 唤醒等待队列中的线程
    wake_up(&data_waitqueue);
    
    return 0;
}

static int __init waitqueue_test_init(void)
{
    struct task_struct *consumer, *producer;
    
    // 初始化等待队列
    init_waitqueue_head(&data_waitqueue);
    
    // 创建消费者线程（先等待）
    consumer = kthread_run(consumer_thread, NULL, "consumer");
    
    msleep(500);  // 让消费者先进入等待
    
    // 创建生产者线程
    producer = kthread_run(producer_thread, NULL, "producer");
    
    return 0;
}
```

## 3. **核心API函数**

### **等待函数（宏）**
```c
// 1. 不可中断等待（不会被信号打断）
wait_event(wq, condition);
// 使用：wait_event(data_waitqueue, data_ready == 1);

// 2. 可中断等待（可被信号打断）
wait_event_interruptible(wq, condition);
// 返回值：0-条件满足，-ERESTARTSYS-被信号打断

// 3. 超时等待
wait_event_timeout(wq, condition, timeout);  // timeout单位：jiffies
// 返回值：剩余时间，0表示超时

// 4. 可中断+超时等待
wait_event_interruptible_timeout(wq, condition, timeout);

// 5. 独占等待（高级用法，避免惊群效应）
wait_event_exclusive(wq, condition);
```

### **唤醒函数**
```c
// 1. 唤醒所有等待者（包括不可中断和可中断）
void wake_up(wait_queue_head_t *q);

// 2. 只唤醒可中断的等待者
void wake_up_interruptible(wait_queue_head_t *q);

// 3. 唤醒特定数量的等待者
void wake_up_nr(wait_queue_head_t *q, int nr);
void wake_up_interruptible_nr(wait_queue_head_t *q, int nr);

// 4. 唤醒所有等待者（包括独占等待）
void wake_up_all(wait_queue_head_t *q);
```

## 4. **手动控制等待过程**

当需要更复杂的等待逻辑时，可以手动控制：

```c
#include <linux/wait.h>

// 定义等待队列项
static DEFINE_WAIT(wait);

static int manual_wait_example(void)
{
    int ret = 0;
    
    // 步骤1：准备等待
    prepare_to_wait(&my_waitqueue, &wait, TASK_INTERRUPTIBLE);
    
    // 步骤2：检查条件，如果条件不满足则调度出去
    while (!condition) {
        // 让出CPU
        schedule();
        
        // 检查是否被信号打断
        if (signal_pending(current)) {
            ret = -ERESTARTSYS;
            break;
        }
        
        // 重新设置状态（如果需要）
        set_current_state(TASK_INTERRUPTIBLE);
    }
    
    // 步骤3：完成等待（清理）
    finish_wait(&my_waitqueue, &wait);
    
    return ret;
}
```

## 5. **完整示例：带缓冲区的生产者-消费者**

```c
#include <linux/module.h>
#include <linux/kthread.h>
#include <linux/wait.h>
#include <linux/slab.h>

#define BUFFER_SIZE 10

static wait_queue_head_t producer_wq;  // 生产者等待队列（缓冲区未满）
static wait_queue_head_t consumer_wq;  // 消费者等待队列（缓冲区不空）
static int buffer[BUFFER_SIZE];
static int in = 0, out = 0;           // 环形缓冲区指针
static int count = 0;                 // 缓冲区中的数据量

// 生产者线程
static int producer(void *data)
{
    int item = 0;
    
    while (!kthread_should_stop()) {
        // 生产一个数据
        item++;
        
        // 等待缓冲区有空间
        wait_event_interruptible(producer_wq, count < BUFFER_SIZE);
        
        // 临界区（实际应该加锁）
        buffer[in] = item;
        in = (in + 1) % BUFFER_SIZE;
        count++;
        
        printk(KERN_INFO "Producer: produced item %d, count=%d\n", item, count);
        
        // 唤醒消费者
        if (count == 1) {  // 缓冲区从空变为非空
            wake_up_interruptible(&consumer_wq);
        }
        
        msleep(500);  // 生产间隔
    }
    
    return 0;
}

// 消费者线程
static int consumer(void *data)
{
    int item;
    
    while (!kthread_should_stop()) {
        // 等待缓冲区有数据
        wait_event_interruptible(consumer_wq, count > 0);
        
        // 临界区（实际应该加锁）
        item = buffer[out];
        out = (out + 1) % BUFFER_SIZE;
        count--;
        
        printk(KERN_INFO "Consumer: consumed item %d, count=%d\n", item, count);
        
        // 唤醒生产者
        if (count == BUFFER_SIZE - 1) {  // 缓冲区从满变为不满
            wake_up_interruptible(&producer_wq);
        }
        
        msleep(800);  // 消费间隔
    }
    
    return 0;
}

static int __init buffer_test_init(void)
{
    struct task_struct *prod, *cons;
    
    // 初始化等待队列
    init_waitqueue_head(&producer_wq);
    init_waitqueue_head(&consumer_wq);
    
    printk(KERN_INFO "Starting producer-consumer test\n");
    
    // 创建生产者和消费者线程
    prod = kthread_run(producer, NULL, "producer");
    cons = kthread_run(consumer, NULL, "consumer");
    
    return 0;
}
```

## 6. **实际应用场景**

### **场景1：设备驱动中的数据等待**
```c
// 字符设备驱动中的read函数
static ssize_t mydev_read(struct file *filp, char __user *buf, 
                         size_t count, loff_t *f_pos)
{
    DEFINE_WAIT(wait);
    
    // 没有数据可读时等待
    while (data_available() == 0) {
        if (filp->f_flags & O_NONBLOCK) {
            return -EAGAIN;  // 非阻塞模式直接返回
        }
        
        prepare_to_wait(&read_waitqueue, &wait, TASK_INTERRUPTIBLE);
        
        // 检查条件，防止竞争
        if (data_available() == 0) {
            schedule();  // 让出CPU
        }
        
        finish_wait(&read_waitqueue, &wait);
        
        // 检查是否被信号打断
        if (signal_pending(current)) {
            return -ERESTARTSYS;
        }
    }
    
    // 读取数据到用户空间
    return copy_to_user(buf, device_buffer, min(count, available_size));
}

// 中断处理函数中唤醒
static irqreturn_t mydev_interrupt(int irq, void *dev_id)
{
    // 接收数据
    receive_data();
    
    // 唤醒等待的read进程
    wake_up_interruptible(&read_waitqueue);
    
    return IRQ_HANDLED;
}
```

### **场景2：多条件等待**
```c
// 等待多个条件之一满足
#define FLAG_A (1 << 0)
#define FLAG_B (1 << 1)
#define FLAG_C (1 << 2)

static unsigned long flags = 0;
static wait_queue_head_t flag_wq;

// 等待特定标志被设置
static int wait_for_flag(unsigned long flag_mask)
{
    int ret = 0;
    DEFINE_WAIT(wait);
    
    prepare_to_wait(&flag_wq, &wait, TASK_INTERRUPTIBLE);
    
    while (!(flags & flag_mask)) {
        schedule();
        
        if (signal_pending(current)) {
            ret = -ERESTARTSYS;
            break;
        }
    }
    
    finish_wait(&flag_wq, &wait);
    
    if (ret == 0) {
        // 清除已处理的标志
        flags &= ~flag_mask;
    }
    
    return ret;
}

// 设置标志并唤醒
static void set_flag(unsigned long flag)
{
    unsigned long old_flags;
    
    spin_lock(&flag_lock);
    old_flags = flags;
    flags |= flag;
    spin_unlock(&flag_lock);
    
    // 如果标志状态发生变化，唤醒等待者
    if (!old_flags && flags) {
        wake_up_interruptible(&flag_wq);
    }
}
```

## 7. **高级用法**

### **7.1 自定义唤醒函数**
```c
// 定义自定义的等待队列项
typedef struct {
    wait_queue_entry_t wait;  // 必须包含这个
    int special_data;
    void (*callback)(void *);
} custom_wait_t;

// 自定义唤醒函数
static int custom_wake_function(wait_queue_entry_t *wait, 
                               unsigned int mode,
                               int sync, void *key)
{
    custom_wait_t *custom = container_of(wait, custom_wait_t, wait);
    
    // 自定义唤醒条件
    if (*(int *)key == custom->special_data) {
        // 执行回调
        if (custom->callback)
            custom->callback(custom);
            
        return 1;  // 唤醒这个等待项
    }
    
    return 0;  // 不唤醒
}

// 使用自定义等待项
static void add_custom_waiter(wait_queue_head_t *wq, int data)
{
    custom_wait_t *waiter;
    
    waiter = kmalloc(sizeof(*waiter), GFP_KERNEL);
    waiter->special_data = data;
    waiter->callback = my_callback;
    
    // 初始化等待项
    init_waitqueue_func_entry(&waiter->wait, custom_wake_function);
    
    // 添加到等待队列
    add_wait_queue(wq, &waiter->wait);
    
    // 设置进程状态并调度出去
    set_current_state(TASK_INTERRUPTIBLE);
    schedule();
    
    // 被唤醒后
    remove_wait_queue(wq, &waiter->wait);
    kfree(waiter);
}
```

### **7.2 等待队列与poll/select**
```c
// 实现poll操作
static unsigned int mydev_poll(struct file *filp, poll_table *wait)
{
    unsigned int mask = 0;
    
    // 将等待队列添加到poll_table
    poll_wait(filp, &read_waitqueue, wait);
    poll_wait(filp, &write_waitqueue, wait);
    
    // 检查条件
    if (data_available() > 0) {
        mask |= POLLIN | POLLRDNORM;  // 可读
    }
    
    if (space_available() > 0) {
        mask |= POLLOUT | POLLWRNORM;  // 可写
    }
    
    return mask;
}
```

## 8. **最佳实践和注意事项**

### **正确使用模式**
```c
// 模式1：使用宏（推荐用于简单条件）
wait_event_interruptible(wq, condition);

// 模式2：手动控制（复杂条件）
DEFINE_WAIT(wait);
while (!complex_condition()) {
    prepare_to_wait(&wq, &wait, state);
    if (!complex_condition())
        schedule();
    finish_wait(&wq, &wait);
}

// 模式3：带锁的保护
DEFINE_WAIT(wait);
spin_lock(&lock);
while (!condition) {
    prepare_to_wait(&wq, &wait, TASK_INTERRUPTIBLE);
    spin_unlock(&lock);
    schedule();
    spin_lock(&lock);
    finish_wait(&wq, &wait);
}
// 处理临界区
spin_unlock(&lock);
```

### **常见错误和解决方法**
```c
// 错误1：忘记检查条件变化导致的竞争
// 错误代码：
if (!condition) {
    wait_event(wq, condition);  // 竞争窗口！
}

// 正确代码：
wait_event(wq, condition);  // 宏内部会检查

// 错误2：未配对使用prepare/finish_wait
// 正确做法：
prepare_to_wait(&wq, &wait, state);
// ... 可能调用schedule()
finish_wait(&wq, &wait);  // 必须调用！

// 错误3：在错误的状态下调用wake_up
// 唤醒前应该设置条件
condition = 1;
wake_up(&wq);  // 在条件设置后唤醒
```

## 9. **与完成队列的比较**

| 特性 | 等待队列（wait_queue） | 完成队列（completion） |
|------|----------------------|----------------------|
| **灵活性** | 高，可自定义唤醒条件 | 低，只检查完成状态 |
| **复杂性** | 较高，需要手动管理 | 低，API简单 |
| **性能** | 稍低，更通用 | 稍高，专门优化 |
| **适用场景** | 复杂等待条件、多个条件 | 简单"完成"通知 |
| **内存占用** | 每个等待项需要额外内存 | 固定大小结构体 |
| **使用频率** | 内核中广泛使用 | 特定场景使用 |

## 10. **调试技巧**

```c
// 1. 添加调试信息
#include <linux/jiffies.h>

static void debug_waitqueue(const char *op, wait_queue_head_t *wq)
{
#ifdef DEBUG
    printk(KERN_DEBUG "WAITQ %s: wq=%p, jiffies=%lu\n", 
           op, wq, jiffies);
#endif
}

// 2. 监控等待队列状态
static void check_waitqueue_status(wait_queue_head_t *wq)
{
    // 检查是否有等待者
    if (waitqueue_active(wq)) {
        printk(KERN_INFO "Waitqueue %p has waiters\n", wq);
    }
}

// 3. 使用tracepoint
// 内核已内置等待队列的tracepoint
echo 1 > /sys/kernel/debug/tracing/events/writeback/enable
```

## 11. **总结**

### **核心要点：**
1. **初始化**：`DECLARE_WAIT_QUEUE_HEAD()`或`init_waitqueue_head()`
2. **等待**：使用`wait_event`系列宏或手动`prepare_to_wait()`/`schedule()`/`finish_wait()`
3. **唤醒**：使用`wake_up()`系列函数
4. **条件检查**：必须在循环中检查条件，防止竞争

### **使用建议：**
```c
// 简单场景：使用宏
wait_event_interruptible(wq, condition);

// 复杂场景：手动控制
DEFINE_WAIT(wait);
prepare_to_wait(&wq, &wait, state);
while (!condition) {
    schedule();
    // 检查信号等
}
finish_wait(&wq, &wait);

// 始终配对使用：
// prepare_to_wait() 必须对应 finish_wait()
// add_wait_queue() 必须对应 remove_wait_queue()
```

### **简单记忆：**
```c
// 等待者：
wait_event_interruptible(wq, data_ready);

// 唤醒者：
data_ready = 1;
wake_up_interruptible(&wq);
```

等待队列是Linux内核同步的基础设施，掌握它的使用对于内核编程至关重要。从简单的事件等待到复杂的条件同步，等待队列都能提供灵活的解决方案。