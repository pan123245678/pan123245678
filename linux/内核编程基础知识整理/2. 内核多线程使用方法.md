# Linux内核线程编程指南

## 1. **内核线程基础概念**

内核线程运行在内核空间，由内核创建和管理：
- 没有独立的地址空间（与用户线程不同）
- 运行在内核态
- 可以访问内核数据结构
- 由内核调度器调度

## 2. **创建内核线程**

### **方法一：kthread_create()**
```c
#include <linux/kthread.h>
#include <linux/sched.h>

struct task_struct *kthread_create(int (*threadfn)(void *data),
                                   void *data,
                                   const char namefmt[], ...);
```

示例：
```c
static struct task_struct *my_thread;

static int my_thread_func(void *data)
{
    while (!kthread_should_stop()) {
        // 线程工作内容
        printk(KERN_INFO "Thread is running\n");
        ssleep(1);  // 睡眠1秒
    }
    return 0;
}

// 创建线程
my_thread = kthread_create(my_thread_func, NULL, "my_kthread");
if (!IS_ERR(my_thread)) {
    wake_up_process(my_thread);  // 启动线程
}
```

### **方法二：kthread_run()（创建并立即运行）**
```c
#define kthread_run(threadfn, data, namefmt, ...) \
({ \
    struct task_struct *k = kthread_create(threadfn, data, namefmt, ##__VA_ARGS__); \
    if (!IS_ERR(k)) \
        wake_up_process(k); \
    k; \
})

// 使用示例
my_thread = kthread_run(my_thread_func, NULL, "my_kthread");
```

## 3. **线程控制**

### **停止线程**
```c
int kthread_stop(struct task_struct *k);
```

示例：
```c
// 模块退出时停止线程
if (my_thread) {
    kthread_stop(my_thread);
    my_thread = NULL;
}
```

### **检查停止信号**
```c
kthread_should_stop()  // 返回true表示线程应该停止
```

## 4. **完整的模块示例**

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kthread.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Kernel Thread Example");

static struct task_struct *my_thread;
static int thread_running = 1;

static int thread_function(void *data)
{
    int count = 0;
    
    while (thread_running && !kthread_should_stop()) {
        printk(KERN_INFO "Kernel thread: iteration %d\n", count++);
        
        // 让出CPU，避免占用过多CPU时间
        set_current_state(TASK_INTERRUPTIBLE);
        schedule_timeout(HZ);  // 睡眠1秒
        
        // 或者使用
        // msleep(1000);  // 睡眠1000毫秒
        // ssleep(1);     // 睡眠1秒
    }
    
    printk(KERN_INFO "Kernel thread exiting\n");
    return 0;
}

static int __init thread_init(void)
{
    printk(KERN_INFO "Initializing kernel thread module\n");
    
    // 创建并运行线程
    my_thread = kthread_run(thread_function, NULL, "my_kernel_thread");
    
    if (IS_ERR(my_thread)) {
        printk(KERN_ERR "Failed to create kernel thread\n");
        return PTR_ERR(my_thread);
    }
    
    return 0;
}

static void __exit thread_exit(void)
{
    printk(KERN_INFO "Exiting kernel thread module\n");
    
    if (my_thread) {
        thread_running = 0;
        kthread_stop(my_thread);
        my_thread = NULL;
    }
}

module_init(thread_init);
module_exit(thread_exit);
```

## 5. **Makefile示例**

```makefile
obj-m += thread_example.o
KERNEL_DIR ?= /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
    $(MAKE) -C $(KERNEL_DIR) M=$(PWD) modules

clean:
    $(MAKE) -C $(KERNEL_DIR) M=$(PWD) clean

install:
    sudo insmod thread_example.ko

remove:
    sudo rmmod thread_example
```

## 6. **线程同步**

### **使用互斥锁**
```c
#include <linux/mutex.h>

static DEFINE_MUTEX(my_mutex);

static int thread_function(void *data)
{
    while (!kthread_should_stop()) {
        mutex_lock(&my_mutex);
        // 临界区
        mutex_unlock(&my_mutex);
        
        schedule_timeout(HZ);
    }
    return 0;
}
```

### **使用完成量**
```c
#include <linux/completion.h>

static DECLARE_COMPLETION(thread_done);

static int thread_function(void *data)
{
    // 工作...
    
    // 通知完成
    complete(&thread_done);
    return 0;
}

// 等待线程完成
wait_for_completion(&thread_done);
```

## 7. **传递参数给线程**

```c
struct thread_data {
    int id;
    char *message;
    struct completion done;
};

static int thread_function(void *data)
{
    struct thread_data *tdata = (struct thread_data *)data;
    
    printk(KERN_INFO "Thread %d: %s\n", tdata->id, tdata->message);
    
    complete(&tdata->done);
    return 0;
}

// 使用
struct thread_data data = {
    .id = 1,
    .message = "Hello from thread",
    .done = COMPLETION_INITIALIZER(data.done)
};

my_thread = kthread_run(thread_function, &data, "param_thread");
wait_for_completion(&data.done);
```

## 8. **线程优先级**

```c
#include <linux/sched.h>

static int thread_function(void *data)
{
    // 设置线程为实时优先级
    struct sched_param param = {
        .sched_priority = 50  // 优先级值，1-99
    };
    
    sched_setscheduler(current, SCHED_FIFO, &param);
    
    // 或者设置为普通优先级
    // set_user_nice(current, -20);  // 最高优先级
    // set_user_nice(current, 19);   // 最低优先级
    
    while (!kthread_should_stop()) {
        // 工作...
        schedule();
    }
    return 0;
}
```

## 9. **注意事项**

1. **不能访问用户空间**：内核线程不能直接访问用户空间内存
2. **避免长时间运行**：应定期调用`schedule()`或睡眠函数
3. **资源清理**：确保在模块退出时停止所有线程
4. **避免竞态条件**：使用适当的同步机制
5. **栈大小有限**：内核线程栈大小通常为8KB或16KB

## 10. **调试技巧**

```c
// 打印线程信息
printk(KERN_INFO "Thread PID: %d\n", current->pid);
printk(KERN_INFO "Thread name: %s\n", current->comm);

// 查看所有内核线程
ps aux | grep "\[.*\]"
// 例如：[kworker], [ksoftirqd], [rcu_sched]等
```

这个指南涵盖了Linux内核线程编程的主要方面。在实际开发中，需要根据具体需求选择合适的线程管理和同步机制。